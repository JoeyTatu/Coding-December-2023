trunk_cli_version: 1.18.0
title: Check [[on-demand] [gofmt:format:Go\coffee-api\cmd\server\main.go:HEAD]]
report:
  - linter:
      command: |
        'C:\Users\Joey\AppData\Local\trunk\tools\go\1.20.4-ed8c40f3740dfc6f70b74f8d9067718f/bin\gofmt.exe' 'Go\coffee-api\cmd\server\main.go'
      stdin_path: |
        C:\Users\Joey\AppData\Local\Temp\trunk\z6yzy13\Go\coffee-api\cmd\server\main.go
      run_from: C:\Users\Joey\AppData\Local\Temp\trunk\z6yzy13\
      timeout: 10m
      rerun: (cd C:\Users\Joey\AppData\Local\Temp\trunk\z6yzy13\; cat C:\Users\Joey\AppData\Local\Temp\trunk\z6yzy13\Go\coffee-api\cmd\server\main.go | env -i 'PATH=C:\Users\Joey\AppData\Local\trunk\tools\go\1.20.4-ed8c40f3740dfc6f70b74f8d9067718f/bin;C:\Users\Joey\AppData\Local\trunk\tools\git-bash\2.40.1-da0c3e1526d36e62bf43d06ec46c5052/bin;C:\Users\Joey\AppData\Local\trunk\tools\git-bash\2.40.1-da0c3e1526d36e62bf43d06ec46c5052/usr/bin' 'C:\Users\Joey\AppData\Local\trunk\tools\go\1.20.4-ed8c40f3740dfc6f70b74f8d9067718f/bin\gofmt.exe' 'Go\coffee-api\cmd\server\main.go')
      affects_cache:
        []
      direct_configs:
        []
      exit_status: exited
      exit_code: 0
      stdout: |
        package main

        import (
        	"fmt"
        	"log"
        	"net/http"
        	"os"

        	"github.com/JoeyTatu/coffee-api/db"
        )

        type Config struct {
        	Port string
        }

        type Application struct {
        	Config Config
        }

        // Global port variable for both Main and Serve
        var port = os.Getenv("PORT") // 8080

        func (app *Application) Serve() error {
        	fmt.Println("API listening on port", port)

        	srv := &http.Server{
        		Addr: fmt.Sprintf(":%s", port),
        	}

        	return srv.ListenAndServe()
        }

        func main() {
        	// fmt.Println("USER:", os.Getenv("USER"))
        	// fmt.Println("PW:", os.Getenv("PW"))

        	var cfg Config
        	cfg.Port = port

        	dsn := os.Getenv("DSN")
        	dbConn, err := db.ConnectPostgres(dsn)
        	if err != nil {
        		log.Fatal("Cannot connect to database!", err)
        	}

        	defer dbConn.DB.Close()

        	app := &Application{
        		Config: cfg,
        	}

        	err = app.Serve()
        	if err != nil {
        		log.Fatal(err)
        	}
        }

      stderr: (none)
    parser: |
      (none)